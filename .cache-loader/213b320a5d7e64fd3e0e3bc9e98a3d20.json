{"remainingRequest":"/Users/eve/development/force/node_modules/babel-loader/lib/index.js??ref--2-1!/Users/eve/development/force/node_modules/@artsy/reaction/src/Router/PreloadLink.tsx","dependencies":[{"path":"/Users/eve/development/force/node_modules/@artsy/reaction/src/Router/PreloadLink.tsx","mtime":1530569767000},{"path":"/Users/eve/development/force/node_modules/@artsy/reaction/.babelrc","mtime":1529423546000},{"path":"/Users/eve/development/force/node_modules/cache-loader/dist/cjs.js","mtime":1510929699000},{"path":"/Users/eve/development/force/node_modules/babel-loader/lib/index.js","mtime":1509489566000}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PreloadLink = void 0;\n\nvar _pick2 = _interopRequireDefault(require(\"lodash/fp/pick\"));\n\nvar _last2 = _interopRequireDefault(require(\"lodash/fp/last\"));\n\nvar _isUndefined2 = _interopRequireDefault(require(\"lodash/fp/isUndefined\"));\n\nvar _isEmpty2 = _interopRequireDefault(require(\"lodash/fp/isEmpty\"));\n\nvar _compose2 = _interopRequireDefault(require(\"lodash/fp/compose\"));\n\nvar Found = _interopRequireWildcard(require(\"found\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactRelay = require(\"react-relay\");\n\nvar _state = require(\"Router/state\");\n\nvar _unstated = require(\"unstated\");\n\nvar _Artsy = require(\"../Components/Artsy\");\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } } function _next(value) { step(\"next\", value); } function _throw(err) { step(\"throw\", err); } _next(); }); }; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\n/**\n * PreloadLink is a wrapper around Found's (and found-relay's) <Link> component.\n * It checks to see if a relay query is attached to a given route and blocks\n * transitions until after the route has loaded.\n *\n * @example\n *\n * return (\n *   <Nav>\n *     <PreloadLink to='/'>Home</PreloadLink>\n *     <PreloadLink to='/artworks'>Artworks</PreloadLink>\n *     <PreloadLink to='/artist/pablo-picasso'>Artist</PreloadLink>\n *   </Nav>\n * )\n *\n * For UI that requires router-connected <Tabs>, can use the <RouterTabs>\n * component which wraps PreloadLink:\n *\n * @example\n *\n * return (\n *   <RouteTabs>\n *     <RouteTab to='/'>Home</RouteTab>\n *     <RouteTab to='/artworks' immediate>Loads immediately in the background</RouteTab>\n *     <RouteTab to='/artist/pablo-picasso'>Artist</RouteTab>\n *   </RouteTabs>\n * )\n */\nvar PreloadLink = (0, _compose2.default)(Found.withRouter, _Artsy.ContextConsumer)(function (preloadLinkProps) {\n  /**\n   * Create a Preloader wrapper to perform relay fetches and render out a <Link>\n   */\n  var Preloader =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inherits(Preloader, _React$Component);\n\n    function Preloader() {\n      var _ref;\n\n      var _temp, _this;\n\n      _classCallCheck(this, Preloader);\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _possibleConstructorReturn(_this, (_temp = _this = _possibleConstructorReturn(this, (_ref = Preloader.__proto__ || Object.getPrototypeOf(Preloader)).call.apply(_ref, [this].concat(args))), Object.defineProperty(_assertThisInitialized(_this), \"handleClick\", {\n        configurable: true,\n        enumerable: true,\n        writable: true,\n        value: function value(event) {\n          event.preventDefault();\n\n          _this.props.onToggleLoading(true);\n\n          _this.fetchData().then(function () {\n            var _this$props = _this.props,\n                router = _this$props.router,\n                replace = _this$props.replace,\n                to = _this$props.to;\n\n            _this.props.onToggleLoading(false);\n\n            if (replace) {\n              router.replace(replace);\n            } else {\n              router.push(to);\n            }\n          });\n        }\n      }), _temp));\n    }\n\n    _createClass(Preloader, [{\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this.props.immediate) {\n          this.fetchData();\n        }\n      }\n      /**\n       * For a given route, check to see if it has a Relay query attached.\n       *\n       * @example\n       *\n       * Given this link:\n       * <PreloadLink to='/home'>Home</PreloadLink>\n       *\n       * Preloader will iterate over the route config and look for a match and\n       * return its `query` value:\n       *\n       * const routes = [\n       *   {\n       *     path: '/home',\n       *     Component: () => <div>Home!</div>\n       *     query: graphql`\n       *       query routes_HomeQuery {\n       *         ...\n       *       }\n       *     `\n       *   }\n       * ]\n       */\n\n    }, {\n      key: \"getRouteQuery\",\n      value: function getRouteQuery() {\n        var _props = this.props,\n            _props$system = _props.system,\n            resolver = _props$system.resolver,\n            relayEnvironment = _props$system.relayEnvironment,\n            router = _props.router,\n            to = _props.to;\n        var _Found$ResolverUtils = Found.ResolverUtils,\n            getRouteMatches = _Found$ResolverUtils.getRouteMatches,\n            getRouteValues = _Found$ResolverUtils.getRouteValues;\n        var location = router.createLocation(to);\n        var match = router.matcher.match(location); // Route is missing query, just pass through\n\n        if (!match) {\n          return;\n        }\n\n        var routes = router.matcher.getRoutes(match);\n\n        var augmentedMatch = _extends({}, match, {\n          routes: routes\n        });\n\n        var routeMatches = getRouteMatches(augmentedMatch);\n        var query = (0, _last2.default)(getRouteValues(routeMatches, function (route) {\n          return route.getQuery;\n        }, function (route) {\n          return route.query;\n        }).filter(function (q) {\n          return !(0, _isUndefined2.default)(q);\n        }));\n        var cacheConfig = (0, _last2.default)(getRouteValues(routeMatches, function (route) {\n          return route.getCacheConfig;\n        }, function (route) {\n          return route.cacheConfig;\n        }).filter(function (caches) {\n          return !(0, _isUndefined2.default)(caches);\n        }));\n        var variables = (0, _last2.default)(resolver.getRouteVariables(match, routeMatches).filter(function (routeVariables) {\n          return !(0, _isUndefined2.default)(routeVariables) && !(0, _isEmpty2.default)(routeVariables);\n        }));\n        return {\n          environment: relayEnvironment,\n          query: query,\n          cacheConfig: cacheConfig,\n          variables: variables\n        };\n      }\n    }, {\n      key: \"fetchData\",\n      value: function fetchData() {\n        var _this2 = this;\n\n        return new Promise(\n        /*#__PURE__*/\n        function () {\n          var _ref2 = _asyncToGenerator(\n          /*#__PURE__*/\n          regeneratorRuntime.mark(function _callee(resolve, reject) {\n            var _this2$getRouteQuery, environment, query, variables, cacheConfig, requirementsMet;\n\n            return regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _this2$getRouteQuery = _this2.getRouteQuery(), environment = _this2$getRouteQuery.environment, query = _this2$getRouteQuery.query, variables = _this2$getRouteQuery.variables, cacheConfig = _this2$getRouteQuery.cacheConfig;\n                    requirementsMet = environment && query;\n\n                    if (requirementsMet) {\n                      _context.next = 5;\n                      break;\n                    }\n\n                    console.warn(\"Attempting to use PreloadLink but relayEnvironment or \" + \"query is missing.\", _this2.props);\n                    return _context.abrupt(\"return\", resolve());\n\n                  case 5:\n                    _context.prev = 5;\n                    _context.next = 8;\n                    return (0, _reactRelay.fetchQuery)(environment, query, variables, cacheConfig);\n\n                  case 8:\n                    resolve(); // FIXME: Handle fetch errors\n                    // router.push('/404')\n\n                    _context.next = 14;\n                    break;\n\n                  case 11:\n                    _context.prev = 11;\n                    _context.t0 = _context[\"catch\"](5);\n                    console.error(\"[Reaction Router/PreloadLink]\", _context.t0);\n\n                  case 14:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, this, [[5, 11]]);\n          }));\n\n          return function (_x, _x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        // Under the hood <Link> desugars to an `<a>` tag. Ensure only whitelisted\n        // props pass through to avoid React warnings.\n        var whitelistedProps = (0, _pick2.default)([\"Component\", \"activeClassName\", \"exact\", \"replace\", \"to\"], this.props);\n        return _react.default.createElement(Found.Link, _extends({}, whitelistedProps, {\n          onClick: this.handleClick\n        }), this.props.children);\n      }\n    }]);\n\n    return Preloader;\n  }(_react.default.Component);\n  /**\n   * Subscribe to PreloadLink state\n   */\n\n\n  Object.defineProperty(Preloader, \"propTypes\", {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: {\n      /**\n       * Load route query data transparently in the background on mount\n       */\n      immediate: _propTypes.default.bool,\n\n      /**\n       * Route to transition to. Uses history.pushState\n       */\n      to: _propTypes.default.string,\n\n      /**\n       * Route to transition to. Uses history.replaceState. Note that `replace`\n       * and `to` are mutually exclusive.\n       */\n      replace: _propTypes.default.string,\n\n      /**\n       * Class to add when the link's to / replace route matches current URL\n       */\n      activeClassName: _propTypes.default.string,\n\n      /**\n       * State handler to toggle fetching\n       */\n      onToggleFetching: _propTypes.default.func.isRequired,\n\n      /**\n       * Injected props from ContextConsumer\n       */\n      system: _propTypes.default.shape({\n        relayEnvironment: _propTypes.default.object.isRequired,\n        routes: _propTypes.default.array.isRequired,\n        resolver: _propTypes.default.object.isRequired\n      }).isRequired\n    }\n  });\n  Object.defineProperty(Preloader, \"defaultProps\", {\n    configurable: true,\n    enumerable: true,\n    writable: true,\n    value: {\n      activeClassName: \"active\",\n      immediate: false,\n      onToggleFetching: function onToggleFetching(x) {\n        return x;\n      }\n    }\n  });\n  return _react.default.createElement(_unstated.Subscribe, {\n    to: [_state.AppState, _state.PreloadLinkState]\n  }, function (app, preloadLink) {\n    return _react.default.createElement(Preloader, _extends({\n      onToggleLoading: preloadLink.toggleLoading,\n      system: app.state.system\n    }, preloadLinkProps));\n  });\n});\nexports.PreloadLink = PreloadLink;",{"version":3,"sources":["node_modules/@artsy/reaction/src/Router/PreloadLink.tsx"],"names":["PreloadLink","Preloader","event","preventDefault","props","onToggleLoading","fetchData","then","router","replace","to","push","immediate","system","resolver","relayEnvironment","Found","ResolverUtils","getRouteMatches","getRouteValues","location","createLocation","match","matcher","routes","getRoutes","augmentedMatch","routeMatches","query","route","getQuery","filter","q","cacheConfig","getCacheConfig","caches","variables","getRouteVariables","routeVariables","environment","Promise","resolve","reject","getRouteQuery","requirementsMet","console","warn","error","whitelistedProps","handleClick","children","Component","bool","string","activeClassName","onToggleFetching","func","isRequired","shape","object","array","x","app","preloadLink","toggleLoading","state","preloadLinkProps"],"mappings":"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","file":"/Users/eve/development/force/node_modules/@artsy/reaction/src/Router/PreloadLink.tsx","sourceRoot":"/Users/eve/development/force","sourcesContent":["import * as Found from \"found\"\nimport { withRouter } from \"found\"\nimport { Link } from \"found\"\nimport { compose, isEmpty, isUndefined, last, pick } from \"lodash/fp\"\nimport PropTypes from \"prop-types\"\nimport React from \"react\"\nimport { fetchQuery } from \"react-relay\"\nimport { QueryRendererProps } from \"react-relay\"\nimport { AppState, PreloadLinkState } from \"Router/state\"\nimport { Subscribe } from \"unstated\"\nimport { ContextConsumer } from \"../Components/Artsy\"\nimport { PreloadLinkProps } from \"./types\"\n\n/**\n * PreloadLink is a wrapper around Found's (and found-relay's) <Link> component.\n * It checks to see if a relay query is attached to a given route and blocks\n * transitions until after the route has loaded.\n *\n * @example\n *\n * return (\n *   <Nav>\n *     <PreloadLink to='/'>Home</PreloadLink>\n *     <PreloadLink to='/artworks'>Artworks</PreloadLink>\n *     <PreloadLink to='/artist/pablo-picasso'>Artist</PreloadLink>\n *   </Nav>\n * )\n *\n * For UI that requires router-connected <Tabs>, can use the <RouterTabs>\n * component which wraps PreloadLink:\n *\n * @example\n *\n * return (\n *   <RouteTabs>\n *     <RouteTab to='/'>Home</RouteTab>\n *     <RouteTab to='/artworks' immediate>Loads immediately in the background</RouteTab>\n *     <RouteTab to='/artist/pablo-picasso'>Artist</RouteTab>\n *   </RouteTabs>\n * )\n */\nexport const PreloadLink = compose(\n  withRouter,\n  ContextConsumer\n)(preloadLinkProps => {\n  /**\n   * Create a Preloader wrapper to perform relay fetches and render out a <Link>\n   */\n  class Preloader extends React.Component<PreloadLinkProps> {\n    static propTypes = {\n      /**\n       * Load route query data transparently in the background on mount\n       */\n      immediate: PropTypes.bool,\n\n      /**\n       * Route to transition to. Uses history.pushState\n       */\n      to: PropTypes.string,\n\n      /**\n       * Route to transition to. Uses history.replaceState. Note that `replace`\n       * and `to` are mutually exclusive.\n       */\n      replace: PropTypes.string,\n\n      /**\n       * Class to add when the link's to / replace route matches current URL\n       */\n      activeClassName: PropTypes.string,\n\n      /**\n       * State handler to toggle fetching\n       */\n      onToggleFetching: PropTypes.func.isRequired,\n\n      /**\n       * Injected props from ContextConsumer\n       */\n      system: PropTypes.shape({\n        relayEnvironment: PropTypes.object.isRequired,\n        routes: PropTypes.array.isRequired,\n        resolver: PropTypes.object.isRequired,\n      }).isRequired,\n    }\n\n    static defaultProps = {\n      activeClassName: \"active\",\n      immediate: false,\n      onToggleFetching: x => x,\n    }\n\n    componentDidMount() {\n      if (this.props.immediate) {\n        this.fetchData()\n      }\n    }\n\n    /**\n     * For a given route, check to see if it has a Relay query attached.\n     *\n     * @example\n     *\n     * Given this link:\n     * <PreloadLink to='/home'>Home</PreloadLink>\n     *\n     * Preloader will iterate over the route config and look for a match and\n     * return its `query` value:\n     *\n     * const routes = [\n     *   {\n     *     path: '/home',\n     *     Component: () => <div>Home!</div>\n     *     query: graphql`\n     *       query routes_HomeQuery {\n     *         ...\n     *       }\n     *     `\n     *   }\n     * ]\n     */\n    getRouteQuery(): Partial<QueryRendererProps> {\n      const {\n        system: { resolver, relayEnvironment },\n        router,\n        to,\n      } = this.props\n\n      const { getRouteMatches, getRouteValues } = Found.ResolverUtils\n      const location = router.createLocation(to)\n      const match = router.matcher.match(location)\n\n      // Route is missing query, just pass through\n      if (!match) {\n        return\n      }\n\n      const routes = router.matcher.getRoutes(match)\n      const augmentedMatch = { ...match, routes }\n      const routeMatches = getRouteMatches(augmentedMatch)\n\n      const query = last(\n        getRouteValues(\n          routeMatches,\n          route => route.getQuery,\n          route => route.query\n        ).filter(q => !isUndefined(q))\n      )\n\n      const cacheConfig = last(\n        getRouteValues(\n          routeMatches,\n          route => route.getCacheConfig,\n          route => route.cacheConfig\n        ).filter(caches => !isUndefined(caches))\n      )\n\n      const variables = last(\n        resolver\n          .getRouteVariables(match, routeMatches)\n          .filter(\n            routeVariables =>\n              !isUndefined(routeVariables) && !isEmpty(routeVariables)\n          )\n      )\n\n      return {\n        environment: relayEnvironment,\n        query,\n        cacheConfig,\n        variables,\n      }\n    }\n\n    fetchData() {\n      return new Promise(async (resolve, reject) => {\n        const {\n          environment,\n          query,\n          variables,\n          cacheConfig,\n        } = this.getRouteQuery()\n\n        const requirementsMet = environment && query\n\n        if (!requirementsMet) {\n          console.warn(\n            \"Attempting to use PreloadLink but relayEnvironment or \" +\n              \"query is missing.\",\n            this.props\n          )\n          return resolve()\n        }\n\n        try {\n          await fetchQuery(environment, query, variables, cacheConfig)\n          resolve()\n\n          // FIXME: Handle fetch errors\n          // router.push('/404')\n        } catch (error) {\n          console.error(\"[Reaction Router/PreloadLink]\", error)\n        }\n      })\n    }\n\n    handleClick = event => {\n      event.preventDefault()\n      this.props.onToggleLoading(true)\n\n      this.fetchData().then(() => {\n        const { router, replace, to } = this.props\n        this.props.onToggleLoading(false)\n\n        if (replace) {\n          router.replace(replace)\n        } else {\n          router.push(to)\n        }\n      })\n    }\n\n    render() {\n      // Under the hood <Link> desugars to an `<a>` tag. Ensure only whitelisted\n      // props pass through to avoid React warnings.\n      const whitelistedProps = pick(\n        [\"Component\", \"activeClassName\", \"exact\", \"replace\", \"to\"],\n        this.props\n      )\n\n      return (\n        <Link {...whitelistedProps} onClick={this.handleClick}>\n          {this.props.children}\n        </Link>\n      )\n    }\n  }\n\n  /**\n   * Subscribe to PreloadLink state\n   */\n  return (\n    <Subscribe to={[AppState, PreloadLinkState]}>\n      {(app: AppState, preloadLink: PreloadLinkState) => {\n        return (\n          <Preloader\n            onToggleLoading={preloadLink.toggleLoading}\n            system={app.state.system}\n            {...preloadLinkProps}\n          />\n        )\n      }}\n    </Subscribe>\n  )\n})\n"]}]}