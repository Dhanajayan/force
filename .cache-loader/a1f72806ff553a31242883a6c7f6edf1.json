{"remainingRequest":"/Users/eve/development/force/node_modules/babel-loader/lib/index.js??ref--2-1!/Users/eve/development/force/node_modules/sprintf-js/src/sprintf.js","dependencies":[{"path":"/Users/eve/development/force/node_modules/sprintf-js/src/sprintf.js","mtime":1494080813000},{"path":"/Users/eve/development/force/.babelrc","mtime":1528124541000},{"path":"/Users/eve/development/force/node_modules/cache-loader/dist/cjs.js","mtime":1510929699000},{"path":"/Users/eve/development/force/node_modules/babel-loader/lib/index.js","mtime":1509489566000}],"contextDependencies":[],"result":["var _Object$create = require(\"@babel/runtime/core-js/object/create\");\n\nvar _JSON$stringify = require(\"@babel/runtime/core-js/json/stringify\");\n\n/* globals window, exports, define */\n(function (window) {\n  'use strict';\n\n  var re = {\n    not_string: /[^s]/,\n    not_bool: /[^t]/,\n    not_type: /[^T]/,\n    not_primitive: /[^v]/,\n    number: /[diefg]/,\n    numeric_arg: /[bcdiefguxX]/,\n    json: /[j]/,\n    not_json: /[^j]/,\n    text: /^[^\\x25]+/,\n    modulo: /^\\x25{2}/,\n    placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n    key: /^([a-z_][a-z_\\d]*)/i,\n    key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n    index_access: /^\\[(\\d+)\\]/,\n    sign: /^[\\+\\-]/\n  };\n\n  function sprintf() {\n    var key = arguments[0],\n        cache = sprintf.cache;\n\n    if (!cache[key]) {\n      cache[key] = sprintf.parse(key);\n    }\n\n    return sprintf.format.call(null, cache[key], arguments);\n  }\n\n  sprintf.format = function (parse_tree, argv) {\n    var cursor = 1,\n        tree_length = parse_tree.length,\n        node_type = '',\n        arg,\n        output = [],\n        i,\n        k,\n        match,\n        pad,\n        pad_character,\n        pad_length,\n        is_positive = true,\n        sign = '';\n\n    for (i = 0; i < tree_length; i++) {\n      node_type = get_type(parse_tree[i]);\n\n      if (node_type === 'string') {\n        output[output.length] = parse_tree[i];\n      } else if (node_type === 'array') {\n        match = parse_tree[i]; // convenience purposes only\n\n        if (match[2]) {\n          // keyword argument\n          arg = argv[cursor];\n\n          for (k = 0; k < match[2].length; k++) {\n            if (!arg.hasOwnProperty(match[2][k])) {\n              throw new Error(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]));\n            }\n\n            arg = arg[match[2][k]];\n          }\n        } else if (match[1]) {\n          // positional argument (explicit)\n          arg = argv[match[1]];\n        } else {\n          // positional argument (implicit)\n          arg = argv[cursor++];\n        }\n\n        if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && get_type(arg) == 'function') {\n          arg = arg();\n        }\n\n        if (re.numeric_arg.test(match[8]) && get_type(arg) != 'number' && isNaN(arg)) {\n          throw new TypeError(sprintf(\"[sprintf] expecting number but found %s\", get_type(arg)));\n        }\n\n        if (re.number.test(match[8])) {\n          is_positive = arg >= 0;\n        }\n\n        switch (match[8]) {\n          case 'b':\n            arg = parseInt(arg, 10).toString(2);\n            break;\n\n          case 'c':\n            arg = String.fromCharCode(parseInt(arg, 10));\n            break;\n\n          case 'd':\n          case 'i':\n            arg = parseInt(arg, 10);\n            break;\n\n          case 'j':\n            arg = _JSON$stringify(arg, null, match[6] ? parseInt(match[6]) : 0);\n            break;\n\n          case 'e':\n            arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential();\n            break;\n\n          case 'f':\n            arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);\n            break;\n\n          case 'g':\n            arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg);\n            break;\n\n          case 'o':\n            arg = arg.toString(8);\n            break;\n\n          case 's':\n            arg = String(arg);\n            arg = match[7] ? arg.substring(0, match[7]) : arg;\n            break;\n\n          case 't':\n            arg = String(!!arg);\n            arg = match[7] ? arg.substring(0, match[7]) : arg;\n            break;\n\n          case 'T':\n            arg = get_type(arg);\n            arg = match[7] ? arg.substring(0, match[7]) : arg;\n            break;\n\n          case 'u':\n            arg = parseInt(arg, 10) >>> 0;\n            break;\n\n          case 'v':\n            arg = arg.valueOf();\n            arg = match[7] ? arg.substring(0, match[7]) : arg;\n            break;\n\n          case 'x':\n            arg = parseInt(arg, 10).toString(16);\n            break;\n\n          case 'X':\n            arg = parseInt(arg, 10).toString(16).toUpperCase();\n            break;\n        }\n\n        if (re.json.test(match[8])) {\n          output[output.length] = arg;\n        } else {\n          if (re.number.test(match[8]) && (!is_positive || match[3])) {\n            sign = is_positive ? '+' : '-';\n            arg = arg.toString().replace(re.sign, '');\n          } else {\n            sign = '';\n          }\n\n          pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' ';\n          pad_length = match[6] - (sign + arg).length;\n          pad = match[6] ? pad_length > 0 ? str_repeat(pad_character, pad_length) : '' : '';\n          output[output.length] = match[5] ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;\n        }\n      }\n    }\n\n    return output.join('');\n  };\n\n  sprintf.cache = _Object$create(null);\n\n  sprintf.parse = function (fmt) {\n    var _fmt = fmt,\n        match = [],\n        parse_tree = [],\n        arg_names = 0;\n\n    while (_fmt) {\n      if ((match = re.text.exec(_fmt)) !== null) {\n        parse_tree[parse_tree.length] = match[0];\n      } else if ((match = re.modulo.exec(_fmt)) !== null) {\n        parse_tree[parse_tree.length] = '%';\n      } else if ((match = re.placeholder.exec(_fmt)) !== null) {\n        if (match[2]) {\n          arg_names |= 1;\n          var field_list = [],\n              replacement_field = match[2],\n              field_match = [];\n\n          if ((field_match = re.key.exec(replacement_field)) !== null) {\n            field_list[field_list.length] = field_match[1];\n\n            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n              if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                field_list[field_list.length] = field_match[1];\n              } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                field_list[field_list.length] = field_match[1];\n              } else {\n                throw new SyntaxError(\"[sprintf] failed to parse named argument key\");\n              }\n            }\n          } else {\n            throw new SyntaxError(\"[sprintf] failed to parse named argument key\");\n          }\n\n          match[2] = field_list;\n        } else {\n          arg_names |= 2;\n        }\n\n        if (arg_names === 3) {\n          throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\");\n        }\n\n        parse_tree[parse_tree.length] = match;\n      } else {\n        throw new SyntaxError(\"[sprintf] unexpected placeholder\");\n      }\n\n      _fmt = _fmt.substring(match[0].length);\n    }\n\n    return parse_tree;\n  };\n\n  var vsprintf = function vsprintf(fmt, argv, _argv) {\n    _argv = (argv || []).slice(0);\n\n    _argv.splice(0, 0, fmt);\n\n    return sprintf.apply(null, _argv);\n  };\n  /**\n   * helpers\n   */\n\n\n  function get_type(variable) {\n    if (typeof variable === 'number') {\n      return 'number';\n    } else if (typeof variable === 'string') {\n      return 'string';\n    } else {\n      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n    }\n  }\n\n  var preformattedPadding = {\n    '0': ['', '0', '00', '000', '0000', '00000', '000000', '0000000'],\n    ' ': ['', ' ', '  ', '   ', '    ', '     ', '      ', '       '],\n    '_': ['', '_', '__', '___', '____', '_____', '______', '_______']\n  };\n\n  function str_repeat(input, multiplier) {\n    if (multiplier >= 0 && multiplier <= 7 && preformattedPadding[input]) {\n      return preformattedPadding[input][multiplier];\n    }\n\n    return Array(multiplier + 1).join(input);\n  }\n  /**\n   * export to either browser or node.js\n   */\n\n\n  if (typeof exports !== 'undefined') {\n    exports.sprintf = sprintf;\n    exports.vsprintf = vsprintf;\n  }\n\n  if (typeof window !== 'undefined') {\n    window.sprintf = sprintf;\n    window.vsprintf = vsprintf;\n\n    if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return {\n          sprintf: sprintf,\n          vsprintf: vsprintf\n        };\n      });\n    }\n  }\n})(typeof window === 'undefined' ? this : window);",{"version":3,"sources":["node_modules/sprintf-js/src/sprintf.js"],"names":["window","re","not_string","not_bool","not_type","not_primitive","number","numeric_arg","json","not_json","text","modulo","placeholder","key","key_access","index_access","sign","sprintf","arguments","cache","parse","format","call","parse_tree","argv","cursor","tree_length","length","node_type","arg","output","i","k","match","pad","pad_character","pad_length","is_positive","get_type","hasOwnProperty","Error","test","isNaN","TypeError","parseInt","toString","String","fromCharCode","parseFloat","toExponential","toFixed","toPrecision","substring","valueOf","toUpperCase","replace","charAt","str_repeat","join","fmt","_fmt","arg_names","exec","field_list","replacement_field","field_match","SyntaxError","vsprintf","_argv","slice","splice","apply","variable","Object","prototype","toLowerCase","preformattedPadding","input","multiplier","Array","exports","define","amd"],"mappings":"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","file":"/Users/eve/development/force/node_modules/sprintf-js/src/sprintf.js","sourceRoot":"/Users/eve/development/force","sourcesContent":["/* globals window, exports, define */\n\n(function(window) {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[\\+\\-]/\n    }\n\n    function sprintf() {\n        var key = arguments[0], cache = sprintf.cache\n        if (!(cache[key])) {\n            cache[key] = sprintf.parse(key)\n        }\n        return sprintf.format.call(null, cache[key], arguments)\n    }\n\n    sprintf.format = function(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length, is_positive = true, sign = ''\n        for (i = 0; i < tree_length; i++) {\n            node_type = get_type(parse_tree[i])\n            if (node_type === 'string') {\n                output[output.length] = parse_tree[i]\n            }\n            else if (node_type === 'array') {\n                match = parse_tree[i] // convenience purposes only\n                if (match[2]) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < match[2].length; k++) {\n                        if (!arg.hasOwnProperty(match[2][k])) {\n                            throw new Error(sprintf('[sprintf] property \"%s\" does not exist', match[2][k]))\n                        }\n                        arg = arg[match[2][k]]\n                    }\n                }\n                else if (match[1]) { // positional argument (explicit)\n                    arg = argv[match[1]]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(match[8]) && re.not_primitive.test(match[8]) && get_type(arg) == 'function') {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(match[8]) && (get_type(arg) != 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf(\"[sprintf] expecting number but found %s\", get_type(arg)))\n                }\n\n                if (re.number.test(match[8])) {\n                    is_positive = arg >= 0\n                }\n\n                switch (match[8]) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                    break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                    break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                    break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, match[6] ? parseInt(match[6]) : 0)\n                    break\n                    case 'e':\n                        arg = match[7] ? parseFloat(arg).toExponential(match[7]) : parseFloat(arg).toExponential()\n                    break\n                    case 'f':\n                        arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg)\n                    break\n                    case 'g':\n                        arg = match[7] ? parseFloat(arg).toPrecision(match[7]) : parseFloat(arg)\n                    break\n                    case 'o':\n                        arg = arg.toString(8)\n                    break\n                    case 's':\n                        arg = String(arg)\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                    break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                    break\n                    case 'T':\n                        arg = get_type(arg)\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                    break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                    break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (match[7] ? arg.substring(0, match[7]) : arg)\n                    break\n                    case 'x':\n                        arg = parseInt(arg, 10).toString(16)\n                    break\n                    case 'X':\n                        arg = parseInt(arg, 10).toString(16).toUpperCase()\n                    break\n                }\n                if (re.json.test(match[8])) {\n                    output[output.length] = arg\n                }\n                else {\n                    if (re.number.test(match[8]) && (!is_positive || match[3])) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = match[4] ? match[4] === '0' ? '0' : match[4].charAt(1) : ' '\n                    pad_length = match[6] - (sign + arg).length\n                    pad = match[6] ? (pad_length > 0 ? str_repeat(pad_character, pad_length) : '') : ''\n                    output[output.length] = match[5] ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output.join('')\n    }\n\n    sprintf.cache = Object.create(null)\n\n    sprintf.parse = function(fmt) {\n        var _fmt = fmt, match = [], parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree[parse_tree.length] = match[0]\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree[parse_tree.length] = '%'\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list[field_list.length] = field_match[1]\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list[field_list.length] = field_match[1]\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list[field_list.length] = field_match[1]\n                            }\n                            else {\n                                throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError(\"[sprintf] failed to parse named argument key\")\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error(\"[sprintf] mixing positional and named placeholders is not (yet) supported\")\n                }\n                parse_tree[parse_tree.length] = match\n            }\n            else {\n                throw new SyntaxError(\"[sprintf] unexpected placeholder\")\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return parse_tree\n    }\n\n    var vsprintf = function(fmt, argv, _argv) {\n        _argv = (argv || []).slice(0)\n        _argv.splice(0, 0, fmt)\n        return sprintf.apply(null, _argv)\n    }\n\n    /**\n     * helpers\n     */\n    function get_type(variable) {\n        if (typeof variable === 'number') {\n            return 'number'\n        }\n        else if (typeof variable === 'string') {\n            return 'string'\n        }\n        else {\n            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase()\n        }\n    }\n\n    var preformattedPadding = {\n        '0': ['', '0', '00', '000', '0000', '00000', '000000', '0000000'],\n        ' ': ['', ' ', '  ', '   ', '    ', '     ', '      ', '       '],\n        '_': ['', '_', '__', '___', '____', '_____', '______', '_______'],\n    }\n    function str_repeat(input, multiplier) {\n        if (multiplier >= 0 && multiplier <= 7 && preformattedPadding[input]) {\n            return preformattedPadding[input][multiplier]\n        }\n        return Array(multiplier + 1).join(input)\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    if (typeof exports !== 'undefined') {\n        exports.sprintf = sprintf\n        exports.vsprintf = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window.sprintf = sprintf\n        window.vsprintf = vsprintf\n\n        if (typeof define === 'function' && define.amd) {\n            define(function() {\n                return {\n                    sprintf: sprintf,\n                    vsprintf: vsprintf\n                }\n            })\n        }\n    }\n})(typeof window === 'undefined' ? this : window);\n"]}]}